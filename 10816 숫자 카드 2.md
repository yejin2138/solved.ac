### 숫자 카드 2

<br>
문제 https://www.acmicpc.net/problem/10816
<br>
<br>


```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int lower_binary(int* arr, int target, int size) {
	int mid, start, end;
	start = 0, end = size - 1;

	while (end > start) {
		mid = (start + end) / 2;
		if (arr[mid] >= target)
			end = mid;
		else start = mid + 1;
	}
	return end;
}

int upper_binary(int* arr, int target, int size) {
	int mid, start, end;
	start = 0, end = size - 1;

	while (end > start) {
		mid = (start + end) / 2;
		if (arr[mid] > target)
			end = mid;
		else start = mid + 1;
	}
	return end;
}

int main() {
	int N, M, temp, lower, upper;

	scanf("%d", &N);
	int* a = (int*)malloc(sizeof(int) * N);

	for (int i = 0; i < N; i++) {
		scanf("%d ", &a[i]);
	}
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N - 1; j++) {
			if (a[j] > a[j + 1]) {
				temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
			}
		}
		
	}

	scanf("%d", &M);
	int* b = (int*)malloc(sizeof(int) * M);
	int* count = (int*)malloc(sizeof(int) * M);
	
	for (int k = 0; k < M;k++) {
		scanf("%d", &b[k]);
		count[k] = 0;
	}
	
	for (int i = 0; i < M; i++) {
		lower = lower_binary(a, a[i], N);
		upper = upper_binary(a, a[i], N);
		if (upper == (N - 1) && a[N - 1] == a[i])
			upper++;
		count[i] = upper - lower;
	}
	for (int i = 0; i < M; i++) {
		printf("%d ", count[i]);
	}
	
	return 0;
}
```
<br>

#### 초기설계
열심히 고민하고 풀었는데 처음에 하나하나씩 비교하는 것은 시간초과가 났다.<br>
그래서 결국 이진 탐색을 선택했고, 이진탐색 공부하면서 구글링을 했는데<br>
Lower bound 란 찾고자 하는 값 이상이 처음 나타나는 위치<br>
특정한 값을 찾아내는 알고리즘이다. 배열 정렬은 퀵소트로 했다. 처음 알게 된 사실 c언어에 퀵정렬 알고리즘이 있다는것,,,,<br>
항상 c언어에 내장함수가 많이 없다고 생각했는데,,, 퀵정렬이 있다니,,<br>
정렬을 하고 나서 값을 찾으면 1을 반환하고 그렇지 않으면 왼쪽 오른쪽으로 피봇을 이동하고 마지막까지 없으면 0을 반환하게 했다.<br>
메모리는 평균정도 쓴것같고 다른것에 비해 쉽게 풀지는 못했다.<br>


![image](https://user-images.githubusercontent.com/84511374/140456213-498e0a0a-e7f4-4460-8bc0-9b88b6edb48d.png)


